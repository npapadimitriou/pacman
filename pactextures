<!-- TUC Computer Graphics Course Sandbox -->

</script><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>PacMaze-3</title>

<!-- external libraries for matrix calculations and maintenance -->
<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

<!-- Code for the vertex shader-->
<script id="shader-vs" type="x-shader/x-vertex">
//attributes for the vertex shader (different for every thread/core that will execute a copy of this)
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

 attribute vec2 aTextureCoord;

	//ModelView and Projection Matrices
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	//Variable to be forwarded to the corresponding thread of the fragment shader
   // varying vec4 vColor;
varying vec2 vTextureCoord;
	//main function of the vertex shader
	//this code will be copied to many shader cores/threads and executed with the associated
	//data for every vertex (matrices, color, etc)
    void main(void) {
	
	//Each vertex is multiplied with the ModelView and Projection matrices and created a fragment
	    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		//Its color is forwarded to the fragment shader
      //  vColor = aVertexColor;
vTextureCoord = aTextureCoord;
    }
</script>

<!-- Code for the fragment shader-->
<script id="shader-fs" type="x-shader/x-fragment">
    //necessary code for compatibility
	precision mediump float;
	//Variable coming from the vertex shader
   // varying vec4 vColor;
   varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
    void main(void) {
	//the fragment gets its color value.
	//in the fragment shader many advanced shading algorithms can be implemented (Phong etc..)
      // gl_FragColor = vColor;
  gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    }
</script>

<!-- Javascript code for the main functionality of the WebGL application-->
<script type="text/javascript">

    //the variable that will accommodate the WebGL context
	//every call to the state machine will be done through this variable
    var gl;

	//Initialize WebGL
    function initGL(canvas) {
        try {
		//get a webgl context
            gl = canvas.getContext("experimental-webgl");
			//assign a viewport width and height based on the HTML canvas element properties
			//(check last lines of code)
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
			//any error is handled here
			//all errors are visible in the console (F12 in Google chrome)
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }





	function startgame(){
document.getElementById("menu").style.display="none";
webGLStart();
}



	//Find and compile shaders (vertex + fragment shader)
    function getShader(gl, id) {
	//gets the shader scripts (vertex + fragment)
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
		//create shaders
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

		//ask WebGL to compile shaders
		//we check for errors here too
		//all errors are visible in the console (F12 in Google chrome)
        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


	
    var shaderProgram;

	//Creates a program from a vertex + fragment shader pair
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
		//link the compiled binaries
        gl.linkProgram(shaderProgram);

		//check for errors, again
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

		//activate current program
		//this sandbox has only on shader pair
		//we can have as many as we wish in more complex applications
        gl.useProgram(shaderProgram);

		//Update attributes for the vertex shader
		//attributes are accessible only from the vertex shader
		//if we want accessible data from a fragment shader we can use uniform variables,
		//or varyings that will be forwarded from the vertex shader to the fragment shader
		
		//Vertex position data
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		//Vertex color data
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

 shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

		//Update uniform variables
		//this variables can be accessed from both the vertex and fragment shader
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
    }


function handleLoadedTexture(texture) {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }


 var MazeBlockTexture;
 var PelletTexture;
 var PacTexture;
 var BlinkyTexture;
 var InkyTexture;
 var PinkyTexture;
 var BlueghostTexture


    function initTexture() {
        MazeBlockTexture = gl.createTexture();
	PelletTexture = gl.createTexture();
	PacTexture = gl.createTexture();
	BlinkyTexture = gl.createTexture();
	InkyTexture = gl.createTexture();
	PinkyTexture = gl.createTexture();
	BlueghostTexture = gl.createTexture();


	MazeBlockTexture.image = new Image();
	PelletTexture.image = new Image();
	PacTexture.image = new Image();
	BlinkyTexture.image = new Image();
	InkyTexture.image = new Image();
	PinkyTexture.image = new Image();
	BlueghostTexture.image = new Image();


    
      
MazeBlockTexture.image.onload = function () {
         handleLoadedTexture(MazeBlockTexture);}
PelletTexture.image.onload = function () {
         handleLoadedTexture(PelletTexture);}
PacTexture.image.onload = function () {
         handleLoadedTexture(PacTexture);}
BlinkyTexture.image.onload = function () {
         handleLoadedTexture(BlinkyTexture);}
InkyTexture.image.onload = function () {
         handleLoadedTexture(InkyTexture);}
PinkyTexture.image.onload = function () {
         handleLoadedTexture(PinkyTexture);}
BlueghostTexture.image.onload = function () {
         handleLoadedTexture(BlueghostTexture);}




MazeBlockTexture.image.src = "maze2.jpeg";
PelletTexture.image.src = "pellettex.jpg";
PacTexture.image.src = "Pacmantex.jpg";
BlinkyTexture.image.src = "Blinkytex.jpg";
InkyTexture.image.src = "Inkytex.jpg";
PinkyTexture.image.src = "Pinkytex.jpg";
BlueghostTexture.image.src = "Blueghosttex.jpg";


  }







	//ModelView and Projection matrices
	//mat4 comes from the external library
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

	//The matrix stack operation are implemented below to handle local transformations
	
	//Push Matrix Operation
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

	//Pop Matrix Operation
    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


	//Sets + Updates matrix uniforms
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


	//Rotation function helper
	function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }


 var cubeVertexPositionBuffer;
    var cubeVertexTextureCoordBuffer;
    var cubeVertexIndexBuffer;//contains indices for chains of vertices to draw triangles/other geometry


	//Vertex, Index and Color Data
    var cubeVertexPositionBuffer; // contains coordinates
    var cubeVertexColorBuffer; //contains color per vertex
 var PacmanVertexColorBuffer; //contains color per vertex for pacman
 var BlinkyVertexColorBuffer;//contains color per vertex for blinky
var PinkyVertexColorBuffer;//contains color per vertex for Pinky
var InkyVertexColorBuffer;//contains color per vertex for Pinky
var BlueghostVertexColorBuffer;//contains color per vertex for blueghost
     var MazeBlocksVertexColorBuffer; //contains color per vertex for maze blocks
     var PelletVertexColorBuffer;//xrwma gia to pellet    var 

	//Initialize VBOs, IBOs and color
    function initBuffers() {
        //Vertex Buffer Object
        cubeVertexPositionBuffer = gl.createBuffer();
		//Bind buffer to ARRAY_BUFFER
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		//every item has 3 coordinates (x,y,z)
        cubeVertexPositionBuffer.itemSize = 3;
		//we have 24 vertices
        cubeVertexPositionBuffer.numItems = 24;


   cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        var textureCoords = [
          // Front face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,

          // Back face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Top face
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,

          // Bottom face
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,

          // Right face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Left face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 24;



		//Index Buffer Object
		//it joins sets of vertices into faces
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
		//this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        //we have one item - the cube
		cubeVertexIndexBuffer.itemSize = 1;
		//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubeVertexIndexBuffer.numItems = 36;
    }

	//Helper Variables
    var rCube = 0;

	//suntetagmenes pacman
	var xTrans = 18.0;
	var yTrans = 10.0;
	//syntetagmenes blinky
	var BlinkyxTrans = 34.0;
	var BlinkyyTrans = 18.0;
	var PinkyxTrans = 10.0;
	var PinkyyTrans = 6.0;
	var InkyxTrans =28.0;
	var InkyyTrans =6.0;
	var swinging = 0.01;
	var Pac_lives=3;
	var movDirection = true;
	
	//array for keeping pressed keys
	var currentlyPressedKeys = {};

	//Keyboard handler
	//do not touch :) 
    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;

        if (String.fromCharCode(event.keyCode) == "F") {
            filter += 1;
            if (filter == 3) {
                filter = 0;
            }
        }
//camera angle
if (String.fromCharCode(event.keyCode) == "C"){
	if (camera_angle==1){
	flagcamera=99;
	camera_angle=2;	}
	else{flagcamera=100;
	camera_angle=1;}
}
}

    

	//Keyboard handler
	//do not touch :) 
    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }


var flag_left=false;
var flag_up=false;
var flag_right=false;
var flag_down=false;
var Blinky_flag_down=false;
var Blinky_flag_up=false;
var Blinky_flag_right=false;
var Blinky_flag_left=false;

var Pinky_flag_down=false;
var Pinky_flag_up=false;
var Pinky_flag_right=false;
var Pinky_flag_left=false;


var Inky_flag_down=false;
var Inky_flag_up=false;
var Inky_flag_right=false;
var Inky_flag_left=false;
var camera_angle=1;

var flagal=0;
var flagcamera=99;
var a=0,b=0,c=0,d=0;

var first_level_pac_dots=97;
var second_level_pac_dots=95;
var level_pac_dots=first_level_pac_dots;

var stage=1;

Blinky_eatable=false;
Pinky_eatable=false;
Inky_eatable=false;
eating_time=0;

	function Movement(move,Xaxis,Yaxis,left,up,right,down){
	    
	    if(move=='up'){




}//end for 'up'	
else if (move=='down'){
}//end of down
else if(move=='right'){
}
else if (move=='left'){





}//end of left
else{
}//no movement

}//end of function Movement







	//Key pressed callback
	//37-40 are the codes for the arrow keys
	//xTrans + yTrans are used in the ModelView matrix for local transformation of the cube
    function handleKeys() {
        if (currentlyPressedKeys[37]||flag_left==true) {
           // Left cursor key
         if(flag_up==false && flag_down==false && flag_left==false && (flag_right==false || flag_right==true)){ //stamatimeno i paei deksia
			flag_left=true;
			flag_right=false;
			flag_up=false;
			flag_down=false;
			 xTrans -= 0.1;
			}
			else if((flag_up==true && (Math.ceil(yTrans+0.5)%2==1 && (yTrans+0.5)%2!=1 && level_maze[Math.floor(yTrans+0.5)/2][(xTrans-2)/2]!="x")) || (flag_down==true && (Math.floor(yTrans+1.5)%2==1 && level_maze[Math.floor(yTrans+0.5)/2][(xTrans-2)/2]!="x"))){ //paei pros ta kato
			flag_left=true;
			flag_right=false;
			flag_up=false;
			flag_down=false;
 			xTrans -= 0.1;
			yTrans=Math.floor(yTrans+0.5);} //to euthigrammizei
/*else if(flag_left==true &&(level_maze[Math.floor((yTrans-0.5)/2)][Math.floor((xTrans-2)/2)]!="x")){
flag_left=true;
			flag_right=false;
			flag_up=false;
			flag_down=false;
 			xTrans -= 0.1;
			}		
*/
	else if(flag_left==true&&((xTrans%2==0 && level_maze[yTrans/2][(xTrans-2)/2]!="x") || (xTrans%2!=0 && level_maze[yTrans/2][(Math.floor(xTrans)-1)/2]!="x"))){
			flag_left=true;
			flag_right=false;
			flag_up=false;
			flag_down=false;
 			xTrans -= 0.1;
}

/*
  xTrans -= 0.1;
flag_left=true;

 */ 




        }//kleinei to left cursor




        if (currentlyPressedKeys[39]||flag_right==true) {
            // Right cursor key
        
if(flag_up==false && flag_down==false && flag_right==false && (flag_left==false || flag_left==true)){ //stamatimeno i paei aristera
			flag_right=true;
			flag_left=false;
			flag_up=false;
			flag_down=false;
 xTrans += 0.1;}
			else if((flag_up==true && (Math.ceil(yTrans+0.5)%2==1 && (yTrans+0.5)%2!=1 && level_maze[Math.floor(yTrans+0.5)/2][(xTrans+2)/2]!="x")) || //paei pros ta pano
			(flag_down==true && (Math.floor(yTrans+1.5)%2==1 && level_maze[Math.floor(yTrans+0.5)/2][(xTrans+2)/2]!="x"))){ //paei pros ta kato
			flag_right=true;
			flag_left=false;
			flag_up=false;
			flag_down=false;
 xTrans += 0.1;
			yTrans=Math.floor(yTrans+0.5);} //euthigrammisi
	else if(flag_right==true &&((xTrans%2==0 && level_maze[yTrans/2][(xTrans+2)/2]!="x") ||
		(xTrans%2!=0 && level_maze[yTrans/2][(Math.floor(xTrans)+2)/2]!="x"))){
flag_right=true;
			flag_left=false;
			flag_up=false;
			flag_down=false;
 xTrans += 0.1;

}	




/*  xTrans += 0.1;
flag_right=true;*/

        }//kleinei to right cursor









        if (currentlyPressedKeys[38]||flag_up==true) {
            // Up cursor key
				if(flag_left==false && flag_right==false && flag_up==false && (flag_down==false || flag_down==true)){ //stamatimeno i paei pros ta kato
			
			
			flag_left=false;
			flag_up=true;
			flag_right=false;
			flag_down=false;
			yTrans -= 0.1;
			}
			else if((flag_right==true && (Math.floor(xTrans+1.5)%2==1 && level_maze[Math.floor((yTrans-2)/2)][Math.floor(xTrans+0.5)/2]!="x")) || //paei pros ta deksia
			((flag_left==true) && (Math.ceil(xTrans+0.5)%2==1 && (level_maze[Math.floor((yTrans-2)/2)][Math.floor(xTrans+1.5)/2]!="x" && level_maze[Math.floor((yTrans-2)/2)][Math.floor(xTrans+0.5)/2]!="x")))){ //paei pros ta aristera
			flag_up=true;
			flag_left=false;
			flag_right=false;
			flag_down=false;
			
			xTrans=Math.floor(xTrans+0.5);
			yTrans -= 0.1;}
else if ((flag_up==true) &&(level_maze[Math.ceil((yTrans-2)/2)][xTrans/2]!='x')){
			
			flag_up=true;
			flag_left=false;
			flag_right=false;
			flag_down=false;

			yTrans -= 0.1;
			}

			}//kleinei to up


        
        if (currentlyPressedKeys[40]||flag_down==true) {
            // Down cursor key
        
			if(flag_left==false && flag_right==false && flag_down==false && (flag_up==false || flag_up==true)){ //stamatimeno i paei pros ta pano
			flag_down=true;
			flag_right=false;
			flag_up=false;
			flag_left=false;
 yTrans += 0.1;}
			else if((flag_right==true && (Math.floor(xTrans+1.5)%2==1 && level_maze[(yTrans+2)/2][Math.floor(xTrans+0.5)/2]!="x")) || //paei pros ta deksia
			(flag_left==true && (Math.ceil(xTrans+0.5)%2==1 && (level_maze[(yTrans+2)/2][Math.floor(xTrans+1.5)/2]!="x" && level_maze[(yTrans+2)/2][Math.floor(xTrans+0.5)/2]!="x")))){ //paei pros ta aristera
			flag_down=true;
			flag_left=false;
			flag_right=false;
			flag_up=false;
 yTrans += 0.1;
			xTrans=Math.floor(xTrans+0.5);}
else if ((flag_down==true) &&(level_maze[Math.floor((yTrans+2)/2)][xTrans/2]!='x')){
			


			flag_up=false;
			flag_left=false;
			flag_right=false;
			flag_down=true;

			yTrans += 0.1;
			}

/*
  yTrans += 0.1;
flag_down=true;*/




        }//kleinei to down cursor
    }// end of handle keys()

 
var blinkymov=0.1;
var Inkymov=0.1;
var flagforup=false;


	function BlinkyMovement(){

//blinkymov=Math.random();

if(blinkymov<0.25){Blinky_flag_left=true;Blinky_flag_right=false;
			Blinky_flag_up=false;
			Blinky_flag_down=false;}
else if(blinkymov<0.5){Blinky_flag_up=true;
			Blinky_flag_right=false;
			Blinky_flag_left=false;
			Blinky_flag_down=false;}
else if (blinkymov<0.75){Blinky_flag_up=false;
			Blinky_flag_right=true;
			Blinky_flag_left=false;
			Blinky_flag_down=false;}
else{Blinky_flag_up=false;
			Blinky_flag_right=false;
			Blinky_flag_left=false;
			Blinky_flag_down=true;}

	if(Blinky_flag_left==true){//tha phgainei aristera
  
		

	 if(((BlinkyxTrans%2==0 && level_maze[BlinkyyTrans/2][(BlinkyxTrans-2)/2]!="x") || //koitaei an proxorisei sto epomeno
		(BlinkyxTrans%2!=0 &&BlinkyxTrans>1.3&& level_maze[BlinkyyTrans/2][(Math.floor(BlinkyxTrans)-1)/2]!="x"))){
 			BlinkyxTrans -= 0.1;
}

else{
BlinkyxTrans=Math.floor(BlinkyxTrans+0.1);
blinkymov=Math.random();}
}//kleinei to if <0.25

///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
else if(Blinky_flag_up==true){//gia to up
	flagforup=true;		
 if(level_maze[Math.ceil((BlinkyyTrans-2)/2)][BlinkyxTrans/2]!='x'){
			BlinkyyTrans -= 0.1;
		}

else{
BlinkyyTrans=Math.floor(BlinkyyTrans+0.1);
blinkymov=Math.random();}
}//kleinei to up






else if(Blinky_flag_right==true){//gia to right

 
	 if(((BlinkyxTrans%2==0 && level_maze[Math.ceil(BlinkyyTrans)/2][(BlinkyxTrans+2)/2]!="x") ||
		(BlinkyxTrans%2!=0 && level_maze[BlinkyyTrans/2][(Math.floor(BlinkyxTrans)+2)/2]!="x"))){
 BlinkyxTrans += 0.1;

}	
else{
BlinkyxTrans=Math.floor(BlinkyxTrans);
blinkymov=Math.random();}
}//kleinei to right

else if(Blinky_flag_down==true){//anoigei to down

 if ( (level_maze[Math.floor((BlinkyyTrans+2)/2)][BlinkyxTrans/2]!='x')){

			BlinkyyTrans += 0.1;
			}
else{
BlinkyyTrans=Math.floor(BlinkyyTrans);
blinkymov=Math.random();}
}//kleinei  to down
else{blinkymov=Math.random();}


}//end of funtion Blinky movement



////////////////////////////////////////////////
//Inky movement
function InkyMovement(){

//Inkymov=Math.random();

if(Inkymov<0.25){Inky_flag_left=true;Inky_flag_right=false;
			Inky_flag_up=false;
			Inky_flag_down=false;}
else if(Inkymov<0.5){Inky_flag_up=true;
			Inky_flag_right=false;
			Inky_flag_left=false;
			Inky_flag_down=false;}
else if (Inkymov<0.75){Inky_flag_up=false;
			Inky_flag_right=true;
			Inky_flag_left=false;
			Inky_flag_down=false;}
else{Inky_flag_up=false;
			Inky_flag_right=false;
			Inky_flag_left=false;
			Inky_flag_down=true;}

	if(Inky_flag_left==true){//tha phgainei aristera
  
		

	 if(((InkyxTrans%2==0 && level_maze[InkyyTrans/2][(InkyxTrans-2)/2]!="x") || //koitaei an proxorisei sto epomeno
		(InkyxTrans%2!=0 &&InkyxTrans>1.3&& level_maze[InkyyTrans/2][(Math.floor(InkyxTrans)-1)/2]!="x"))){
 			InkyxTrans -= 0.1;
}

else{
InkyxTrans=Math.floor(InkyxTrans+0.1);
Inkymov=Math.random();}
}//kleinei to if <0.25

///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
else if(Inky_flag_up==true){//gia to up
	flagforup=true;		
 if(level_maze[Math.ceil((InkyyTrans-2)/2)][InkyxTrans/2]!='x'){
			InkyyTrans -= 0.1;
		}

else{
InkyyTrans=Math.floor(InkyyTrans+0.1);
Inkymov=Math.random();}
}//kleinei to up






else if(Inky_flag_right==true){//gia to right

 
	 if(((InkyxTrans%2==0 && level_maze[Math.ceil(InkyyTrans)/2][(InkyxTrans+2)/2]!="x") ||
		(InkyxTrans%2!=0 && level_maze[InkyyTrans/2][(Math.floor(InkyxTrans)+2)/2]!="x"))){
 InkyxTrans += 0.1;

}	
else{
InkyxTrans=Math.floor(InkyxTrans);
Inkymov=Math.random();}
}//kleinei to right

else if(Inky_flag_down==true){//anoigei to down

 if ( (level_maze[Math.floor((InkyyTrans+2)/2)][InkyxTrans/2]!='x')){

			InkyyTrans += 0.1;
			}
else{
InkyyTrans=Math.floor(InkyyTrans);
Inkymov=Math.random();}
}//kleinei  to down
else{Inkymov=Math.random();}


}//end of funtion Inky movement



////////////////////////////////////////////////////////////
////pinky movement

function PinkyMovement(){

 if (currentlyPressedKeys[37]||Pinky_flag_left==true) {



 if(Pinky_flag_up==false && Pinky_flag_down==false && Pinky_flag_left==false && (Pinky_flag_right==false || Pinky_flag_right==true)){ //stamatimeno i paei deksia
			Pinky_flag_left=true;
			Pinky_flag_right=false;
			Pinky_flag_up=false;
			Pinky_flag_down=false;
			 PinkyxTrans -= 0.1;
			}
			else if((Pinky_flag_up==true && (Math.ceil(PinkyyTrans+0.5)%2==1 && (PinkyyTrans+0.5)%2!=1 && level_maze[Math.floor(PinkyyTrans+0.5)/2][(PinkyxTrans-2)/2]!="x")) || (Pinky_flag_down==true && (Math.floor(PinkyyTrans+1.5)%2==1 && level_maze[Math.floor(PinkyyTrans+0.5)/2][(PinkyxTrans-2)/2]!="x"))){ //paei pros ta kato
			Pinky_flag_left=true;
			Pinky_flag_right=false;
			Pinky_flag_up=false;
			Pinky_flag_down=false;
 			PinkyxTrans -= 0.1;
			PinkyyTrans=Math.floor(PinkyyTrans+0.5);} //to euthigrammizei
else if(Pinky_flag_left==true &&(level_maze[Math.floor((PinkyyTrans-0.5)/2)][Math.floor((PinkyxTrans-2)/2)]!="x")){
Pinky_flag_left=true;
			Pinky_flag_right=false;
			Pinky_flag_up=false;
			Pinky_flag_down=false;
 			PinkyxTrans -= 0.1;
			}		

	else if(Pinky_flag_left==true&&PinkyxTrans>2.3&&((PinkyxTrans%2==0 && level_maze[PinkyyTrans/2][(PinkyxTrans-2)/2]!="x") || (PinkyxTrans%2!=0 &&PinkyxTrans>2.3&& level_maze[PinkyyTrans/2][(Math.floor(PinkyxTrans)-1)/2]!="x"))){
			Pinky_flag_left=true;
			Pinky_flag_right=false;
			Pinky_flag_up=false;
			Pinky_flag_down=false;
 			PinkyxTrans -= 0.1;
}







//////////////////////////////////////////
///////////end of pinky movement
        }//kleinei to left cursor




        if (currentlyPressedKeys[39]||Pinky_flag_right==true) {
            // Right cursor key
   
////////////////////////////////////////////////////////////
////pinky movement

      
if(Pinky_flag_up==false && Pinky_flag_down==false && Pinky_flag_right==false && (Pinky_flag_left==false || Pinky_flag_left==true)){ //stamatimeno i paei aristera
			Pinky_flag_right=true;
			Pinky_flag_left=false;
			Pinky_flag_up=false;
			Pinky_flag_down=false;
 PinkyxTrans += 0.1;}
			else if((Pinky_flag_up==true && (Math.ceil(PinkyyTrans+0.5)%2==1 && (PinkyyTrans+0.5)%2!=1 && level_maze[Math.floor(PinkyyTrans+0.5)/2][(PinkyxTrans+2)/2]!="x")) || //paei pros ta pano
			(Pinky_flag_down==true && (Math.floor(PinkyyTrans+1.5)%2==1 && level_maze[Math.floor(PinkyyTrans+0.5)/2][(PinkyxTrans+2)/2]!="x"))){ //paei pros ta kato
			Pinky_flag_right=true;
			Pinky_flag_left=false;
			Pinky_flag_up=false;
			Pinky_flag_down=false;
 PinkyxTrans += 0.1;
			PinkyyTrans=Math.floor(PinkyyTrans+0.5);} //euthigrammisi
	else if(Pinky_flag_right==true &&((PinkyxTrans%2==0 && level_maze[PinkyyTrans/2][(PinkyxTrans+2)/2]!="x") ||
		(PinkyxTrans%2!=0 && level_maze[PinkyyTrans/2][(Math.floor(PinkyxTrans)+2)/2]!="x"))){
Pinky_flag_right=true;
			Pinky_flag_left=false;
			Pinky_flag_up=false;
			Pinky_flag_down=false;
 PinkyxTrans += 0.1;

}	







//////////////////////////////////////////
///////////end of pinky movement
        }//kleinei to right cursor









        if (currentlyPressedKeys[38]||Pinky_flag_up==true) {
            // Up cursor key
				

////////////////////////////////////////////////////////////
////pinky movement

if(Pinky_flag_left==false && Pinky_flag_right==false && Pinky_flag_up==false && (Pinky_flag_down==false || Pinky_flag_down==true)){ //stamatimeno i paei pros ta kato
			
			
			Pinky_flag_left=false;
			Pinky_flag_up=true;
			Pinky_flag_right=false;
			Pinky_flag_down=false;
			PinkyyTrans -= 0.1;
			}
			else if((Pinky_flag_right==true && (Math.floor(PinkyxTrans+1.5)%2==1 && level_maze[Math.floor((PinkyyTrans-2)/2)][Math.floor(PinkyxTrans+0.5)/2]!="x")) || //paei pros ta deksia
			((Pinky_flag_left==true) && (Math.ceil(PinkyxTrans+0.5)%2==1 && (level_maze[Math.floor((PinkyyTrans-2)/2)][Math.floor(PinkyxTrans+1.5)/2]!="x" && level_maze[Math.floor((PinkyyTrans-2)/2)][Math.floor(PinkyxTrans+0.5)/2]!="x")))){ //paei pros ta aristera
			Pinky_flag_up=true;
			Pinky_flag_left=false;
			Pinky_flag_right=false;
			Pinky_flag_down=false;
			
			PinkyxTrans=Math.floor(PinkyxTrans+0.5);
			PinkyyTrans -= 0.1;}
else if ((Pinky_flag_up==true) &&(level_maze[Math.ceil((PinkyyTrans-2)/2)][PinkyxTrans/2]!='x')){
			
			Pinky_flag_up=true;
			Pinky_flag_left=false;
			Pinky_flag_right=false;
			Pinky_flag_down=false;

			PinkyyTrans -= 0.1;
			}




			}//kleinei to up

            
        
        if (currentlyPressedKeys[40]||Pinky_flag_down==true) {
            // Down cursor key
        
			

if(Pinky_flag_left==false && Pinky_flag_right==false && Pinky_flag_down==false && (Pinky_flag_up==false || Pinky_flag_up==true)){ //stamatimeno i paei pros ta pano
			Pinky_flag_down=true;
			Pinky_flag_right=false;
			Pinky_flag_up=false;
			Pinky_flag_left=false;
 PinkyyTrans += 0.1;}
			else if((Pinky_flag_right==true && (Math.floor(PinkyxTrans+1.5)%2==1 && level_maze[(PinkyyTrans+2)/2][Math.floor(PinkyxTrans+0.5)/2]!="x")) || //paei pros ta deksia
			(Pinky_flag_left==true && (Math.ceil(PinkyxTrans+0.5)%2==1 && (level_maze[(PinkyyTrans+2)/2][Math.floor(PinkyxTrans+1.5)/2]!="x" && level_maze[(PinkyyTrans+2)/2][Math.floor(PinkyxTrans+0.5)/2]!="x")))){ //paei pros ta aristera
			Pinky_flag_down=true;
			Pinky_flag_left=false;
			Pinky_flag_right=false;
			Pinky_flag_up=false;
 PinkyyTrans += 0.1;
			PinkyxTrans=Math.floor(PinkyxTrans+0.5);}
else if ((Pinky_flag_down==true) &&(level_maze[Math.floor((PinkyyTrans+2)/2)][PinkyxTrans/2]!='x')){
			


			Pinky_flag_up=false;
			Pinky_flag_left=false;
			Pinky_flag_right=false;
			Pinky_flag_down=true;

			PinkyyTrans += 0.1;
			}







//////////////////////////////////////////
///////////end of pinky movement





        }//kleinei to down cursor




}//end of function pinky movement






 function whoeatswhom(){
//gia ton pinky
	if((Math.abs(PinkyxTrans-xTrans)<0.5) && (Math.abs(PinkyyTrans-yTrans)<0.5)){
if(Pinky_eatable==false){
flagal=34;
Pac_lives=Pac_lives-1;
xTrans=18;
yTrans=10;
}
else{
Pinky_eatable=false;
PinkyxTrans=10;
PinkyyTrans=6;
}

}

//gia to blinky
	if((Math.abs(BlinkyxTrans-xTrans)<0.5)&&Math.abs(BlinkyyTrans-yTrans)<0.5){
if(Blinky_eatable==false){
Pac_lives=Pac_lives-1;
xTrans=18;
yTrans=10;
}
else{
Blinky_eatable=false;
BlinkyxTrans=34;
BlinkyyTrans=18;
}
}

//gia to Inky
if((Math.abs(InkyxTrans-xTrans)<0.5)&&Math.abs(InkyyTrans-yTrans)<0.5){
if(Inky_eatable==false){
Pac_lives=Pac_lives-1;
xTrans=18.0;
yTrans=10.0;
}
else{
Inky_eatable=false;
InkyxTrans=28.0;
InkyyTrans=6.0;
}
}


	}//funvtion end whoeatswhom
var flagpl=false;

var munching= new Audio("pacman_chomp.wav");
munching.volume=0.5;
munching.playbackRate = 1.5;
munching.load();




 function eating_pellets(){

	if (flag_up==true){
		if(Math.ceil(yTrans)%2==1 && (yTrans)%2!=1 && (level_maze[Math.floor(yTrans)/2][xTrans/2]=="p")){
level_maze[Math.floor(yTrans)/2][xTrans/2]="e";
level_pac_dots--;
munching.play();
}	
else if	(Math.ceil(yTrans)%2==1 && (yTrans)%2!=1 && (level_maze[Math.floor(yTrans)/2][xTrans/2]=="U")){
level_maze[Math.floor(yTrans)/2][xTrans/2]="e";
level_pac_dots--;
Blinky_eatable=true;
Pinky_eatable=true;
Inky_eatable=true;
eating_time=500;
munching.play();
}
			}// end of flag_up
 else if (flag_right==true){
	if(level_maze[Math.floor(yTrans)/2][Math.floor((xTrans+0.5)/2)]=="p"){
level_maze[Math.floor(yTrans)/2][Math.floor((xTrans+0.5)/2)]="e";
level_pac_dots--;
munching.play();
}

else if (level_maze[Math.floor(yTrans)/2][Math.floor((xTrans+0.5)/2)]=="U"){
level_maze[Math.floor(yTrans)/2][Math.floor((xTrans+0.5)/2)]="e";
Blinky_eatable=true;
Pinky_eatable=true;
Inky_eatable=true;
eating_time=500;
level_pac_dots--;
munching.play();

}
}//end of flag right
  else if(flag_left==true){
	if(Math.ceil(xTrans)%2==1 && (level_maze[yTrans/2][Math.floor(xTrans)/2]=="p")){
level_maze[Math.floor(yTrans)/2][Math.floor((xTrans+0.5)/2)]="e";
level_pac_dots--;
flagpl=true;
munching.play();}

else if(level_maze[Math.floor(yTrans)/2][Math.floor((xTrans-0.5)/2)]=="U"){
level_maze[Math.floor(yTrans)/2][Math.floor((xTrans+0.5)/2)]="e";
Blinky_eatable=true;
Pinky_eatable=true;
eating_time=500;
level_pac_dots--;
munching.play();
}


}//end of flag left 

   else if(flag_down==true){
	if(Math.floor(yTrans+2)%2==1 && (level_maze[(Math.floor(yTrans)+1)/2][xTrans/2]=="p")){
level_maze[(Math.floor(yTrans)+1)/2][xTrans/2]="e";
level_pac_dots--;
munching.play();
}		

else if(Math.floor(yTrans+2)%2==1 && (level_maze[(Math.floor(yTrans)+1)/2][xTrans/2]=="U")){
level_maze[(Math.floor(yTrans)+1)/2][xTrans/2]="e";
Blinky_eatable=true;
Pinky_eatable=true;
Inky_eatable=true;
eating_time=500;
level_pac_dots--;
munching.play();
}		



}//end of flag down


}//end of function eating pellets



function eating_timer(){

	if (eating_time==0){
			Blinky_eatable=false;
			Pinky_eatable=false;
			Inky_eatable=false;
			}
	else{
		eating_time=eating_time-1;
	}
}//end of function eating timer
	

//first level maze
 var first_level_maze=[
['x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x'],//0
['x','p','p','p','p','x','p','p','p','p','p','p','p','x','p','p','p','p','x'],//1
['x','x','x','x','p','x','p','x','x','x','x','x','p','x','p','x','x','x','x'],//2
['x','p','p','p','p','p','p','p','p','x','p','p','p','p','p','p','p','p','x'],//3
['x','U','x','x','p','x','x','x','p','x','p','x','x','x','p','x','x','U','x'],//4
['x','p','p','x','p','p','p','p','p','p','p','p','p','p','p','x','p','p','x'],//5
['x','x','p','x','p','x','p','x','x','x','x','x','p','x','p','x','p','x','x'],//6
['x','p','p','p','p','x','p','p','p','x','p','p','p','x','p','p','p','p','x'],//7
['x','p','x','x','x','x','x','x','p','x','p','x','x','x','x','x','x','p','x'],//8
['x','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','x'],//9
['x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x'],//10
];


var second_level_maze=[
['x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x'],//0
['x','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','x'],//1
['x','p','x','x','x','p','x','x','x','p','x','p','x','p','x','x','x','p','x'],//2
['x','p','x','x','x','p','x','U','p','p','x','p','x','p','p','p','x','p','x'],//3
['x','p','x','x','x','p','x','p','x','x','x','p','x','x','x','p','x','p','x'],//4
['x','p','x','x','x','p','p','p','p','p','p','p','p','p','p','p','p','p','x'],//5
['x','p','p','p','p','p','x','p','x','x','x','p','x','x','x','p','x','p','x'],//6
['x','p','x','x','x','p','x','p','p','p','x','p','x','p','p','U','x','p','x'],//7
['x','p','x','x','x','p','x','x','x','p','x','p','x','p','x','x','x','p','x'],//8
['x','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','p','x'],//9
['x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x','x'],//10
]; 

var level_maze=first_level_maze;





	//For every frame this function draws the complete scene from the beginning




  function drawScene() {
	
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		//the projection matrix (pMatrix) is set
		//45 degrees Field-Of-View
		//aspect ratio gl.viewportWidth / gl.viewportHeight
		//near plane: 0.1 , far plane: 100
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);


		//the modelview Matrix is initialized with the Identity Matrix
        mat4.identity(mvMatrix);
		
		//the ModelView matrix gets a global transformation ("camera" retracts 8 units)
		
if (camera_angle==1){
		//REMEMBER there is no actual camera in WebGL
		mat4.translate(mvMatrix, [-18,10, -35.0]);

		 mat4.rotate(mvMatrix, degToRad(90), [1, 0, 0]);
               // mat4.rotate(mvMatrix, -145/180, [0, 0, 1]);
		
		//Keyboard controlled cube
		//we use the matrix stack to employ a local transformation to the cube
}
else{	
mat4.rotate(mvMatrix, degToRad(50), [1,0,0]);
		mvPushMatrix();
		mat4.translate(mvMatrix, [-xTrans, -10, -yTrans-15]); 
		mvPushMatrix();}



/* gia to pacman*/

		mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [xTrans,0.0 , yTrans]);
		
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		

gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
 
gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, PacTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);



		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();



//////////////////////////////////////////////////////////////////
/*gia to blinky*/
	mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [BlinkyxTrans,0.0 , BlinkyyTrans]);
		//mat4.scale(mvMatrix, [0.8, 0.8, 0.8]);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);


gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		

if (Blinky_eatable==false)
{
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, BlinkyTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);
}
else{

     gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, BlueghostTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);
}


		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();

////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
///////gia to pinky
//////////////////////////////////////////////////////////
/*gia to Pinky*/

mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [PinkyxTrans,0.0 , PinkyyTrans]);
		//mat4.scale(mvMatrix, [0.8, 0.8, 0.8]);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		


gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);



if (Pinky_eatable==false){
  gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, PinkyTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);
       }
else{
   gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, BlueghostTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);
}
		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();


///////////////////////////////////////////////////////////////

///////////////////////////////////////////////
//////////gia ton Inky


mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [InkyxTrans,0.0 , InkyyTrans]);
		//mat4.scale(mvMatrix, [0.8, 0.8, 0.8]);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube colors


  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);


if (Inky_eatable==false){
  gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, InkyTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);
       }
else{
   gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, BlueghostTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

}
		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();






///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////
/*for the first level*/

	for (var i = 0; i < 11; i++){
		for (var z = 0; z < 19; z++){
/*elegxos gia to an exoume maze block*/
			if(level_maze[i][z]=="x"){
			    mvPushMatrix();
			    mat4.translate(mvMatrix, [(z*2) ,0,(i*2)]);
		 gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);


  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);



        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, MazeBlockTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

/*
		//we bind the buffer for the cube colors
        gl.bindBuffer(gl.ARRAY_BUFFER, MazeBlocksVertexColorBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, MazeBlocksVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

*/
		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		//////////////////////////////////////////////////////////
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();

					}//end if

/*elegxos gia to an exoume pellet*/
if(level_maze[i][z]=="p"){
  mvPushMatrix();
			    mat4.translate(mvMatrix, [(z*2) ,0,(i*2)]);
mat4.scale(mvMatrix, [0.3, 0.3, 0.3]);
		 gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

  
gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);



        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, PelletTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);


		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		//////////////////////////////////////////////////////////
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();

}

else if (level_maze[i][z]=="U"){


		mvPushMatrix();
		mat4.translate(mvMatrix, [(z*2) ,0,(i*2)]);
		 
		mat4.scale(mvMatrix, [0.5, 0.5, 0.5]);
			//Move pivot point to an edge
			//mat4.translate(mvMatrix, [0.0, 0.0  , 1.0]);
			mat4.rotate(mvMatrix, degToRad(rCube), [0, 1,0]);
			//mat4.translate(mvMatrix, [-1.0, -1.0  , 0.0]);


gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);



        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, PelletTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
	
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();



}//end of power pellet

					     }//end for
				    }	//end for

		
    }

		//animation parameter
	    var lastTime = 0;

		var counter = 0.0;


	//Animate function
    function animate() {


        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

				//adjust a constant rotation speed independently of platform/framerate
		    rCube -= (75 * elapsed) / 1000.0;
			
				counter += elapsed;
				if (counter > 1000.0){
					movDirection = !movDirection;
					counter = 0;
					}
				if (movDirection)
					swinging += (1 * elapsed) / 1000.0;
				else 
					swinging -= (1 * elapsed) / 1000.0;
				
			
		}
		lastTime = timeNow;



	    }//end of animate


	function game_flow(){

	if (Pac_lives==0){
document.getElementById("game-over").style.display = "block";
document.getElementById("TUCWebGL").style.display="none";
}

if (level_pac_dots==0 && stage==1){
stage=2;
level_maze=second_level_maze;
level_pac_dots=second_level_pac_dots;
xTrans=18;
yTrans=10;
 BlinkyxTrans = 34.0;
	 BlinkyyTrans = 18.0;
	 PinkyxTrans = 10.0;
	 PinkyyTrans = 6.0;
}

if (level_pac_dots==0 && stage==2)
{
document.getElementById("game-over").style.display = "block";
document.getElementById("TUCWebGL").style.display="none";
}

}//end of function of game flow
	
var insertcoin=true


	//this is the requestAnimFrame callback
	//For every tick, request another frame
	//handle keyboard, draw the scene, animate (update animation variebles) and continue
    function tick() {
	/*if(insertcoin==true){
	insertcoin=false
	document.getElementById("game-over").style.display = "block";
	document.getElementById("TUCWebGL").style.display="none";

	}*/
        requestAnimFrame(tick);
	handleKeys();
	eating_pellets();
	whoeatswhom();
	eating_timer();
	BlinkyMovement();
	PinkyMovement();
	InkyMovement();
	game_flow();
        drawScene();
        animate();
				
    }

	//Entry point of the WebGL context
	function webGLStart() {
        var canvas = document.getElementById("TUCWebGL");
        
		//Functions for initialization
		//Check above
		initGL(canvas);
        initShaders()
        initBuffers();
	initTexture();
		//Background Color: Color assigned for all pixels with no corresponding fragments
        gl.clearColor(0.3, 0.3, 0.3, 1.0);
		
		//Enable z-buffer for depth sorting
        gl.enable(gl.DEPTH_TEST);

		//define the keyboard handlers
		document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
		
		//the first tick of our application
        tick();
    }
//end of Javascript
</script>

</head>

<style>

#first {
margin-left: 200px;
margin-top:-60px;
}
#second{
margin-left: 360px;
margin-top:20px;
}
.let{

font-size: 30px;
 font-style: italic;
font-weight: bold;
color:rgb(255,255,255);
}

.let:hover {
	color: #0F243E;
}


</style>


<!-- HMTL for the canvas element-->
<body>
<img  id="menu"  style = "display: block; top: 0px;" width="550" height="300" src="pac-man-front.jpg"/>	
<div id="first" class="let"style="cursor:pointer;" onclick="startgame()"  >
Single player
</div>

<!-- onload="webGLStart();" -->
<!-- calls the entry point of our application -->
<img id="game-over" style = "display: none; top: 0px;" width="550" height="300" src="./gameover.png"/>	 

<img id="menu" style = "display: none; top: 0px;" width="550" height="300" src="pac-man-front.jpg"/>
    <canvas id="TUCWebGL" style="border: none;" width="550" height="300"></canvas>



    <br>

</body></html>
